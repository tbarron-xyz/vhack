use crate::result_classification::{classify_with_openai, JailbreakAttemptResultClassification};
use crate::results_report::ResultEntry;
use async_openai::config::OpenAIConfig;
use async_openai::Client;
use chrono::Utc;
use csv;
use futures::future::join_all;
use reqwest::Client as ReqwestClient;
use serde_json;
use std::env;
use std::fs::OpenOptions;
use std::io::Write;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::spawn;
use tokio::sync::Mutex;

pub async fn process_prompts(
    client: &ReqwestClient,
    openai_client: &Client<OpenAIConfig>,
    prompts: Vec<(String, String, String)>,
    filter_test_type: &Option<String>,
    target_url: &str,
    output_file: Arc<Mutex<std::fs::File>>,
    api_max_retries: usize,
    evaluation_model: &str,
) -> Result<Vec<ResultEntry>, Box<dyn std::error::Error + Send + Sync>> {
    let mut results = Vec::new();

    for (test_type, security_level, prompt) in prompts {
        // Filter by test type if specified
        if let Some(ref filter) = filter_test_type {
            if test_type != *filter {
                continue;
            }
        }

        // First: Set security level (without manual session ID)
        let config_payload = serde_json::json!({
            "security_level": security_level
        });

        println!("ðŸ“¡ POST /api/config - requesting session creation");
        let mut config_retries = 0;
        let config_resp = loop {
            match client.post(format!("{}/api/config", target_url)).json(&config_payload).send().await {
                Ok(resp) => break resp,
                Err(e) => {
                    if config_retries < api_max_retries {
                        config_retries += 1;
                        continue;
                    } else {
                        let error_entry = ResultEntry {
                            test_type: test_type.clone(),
                            security_level: security_level.clone(),
                            classification_result: JailbreakAttemptResultClassification::Error,
                            prompt_text: prompt.clone(),
                            reason: None,
                            full_response: format!("Config request send failed: {}", e),
                            timestamp: Utc::now(),
                        };
                        {
                            let mut file = output_file.lock().await;
                            let json_line = serde_json::to_string(&error_entry)
                                .unwrap_or_else(|_| r#"{"error":"serialization_failed"}"#.to_string());
                            let _ = writeln!(file, "{}", json_line);
                        }
                        results.push(error_entry);
                        continue;
                    }
                }
            }
        };

        if !config_resp.status().is_success() {
            eprintln!(
                "Error: Failed to set {} security level (status {})",
                security_level,
                config_resp.status()
            );
            let error_entry = ResultEntry {
                test_type: test_type.clone(),
                security_level: security_level.clone(),
                classification_result: JailbreakAttemptResultClassification::Error,
                prompt_text: prompt.clone(),
                reason: None,
                full_response: format!(
                    "Failed to set {} security level (status {})",
                    security_level,
                    config_resp.status()
                ),
                timestamp: Utc::now(),
            };
            results.push(error_entry);
            continue;
        }

        // The client will automatically store session cookies from the response
        println!("ðŸ”„ Session created and cookies stored");

        // Verify security level is actually set to medium
        println!("ðŸ“¡ GET /api/config - using stored cookies");
        let mut verify_retries = 0;
        let verify_resp = loop {
            match client.get(format!("{}/api/config", target_url)).send().await {
                Ok(resp) => break resp,
                Err(e) => {
                    if verify_retries < api_max_retries {
                        verify_retries += 1;
                        continue;
                    } else {
                        let error_entry = ResultEntry {
                            test_type: test_type.clone(),
                            security_level: security_level.clone(),
                            classification_result: JailbreakAttemptResultClassification::Error,
                            prompt_text: prompt.clone(),
                            reason: None,
                            full_response: format!("Config verification request send failed: {}", e),
                            timestamp: Utc::now(),
                        };
                        {
                            let mut file = output_file.lock().await;
                            let json_line = serde_json::to_string(&error_entry)
                                .unwrap_or_else(|_| r#"{"error":"serialization_failed"}"#.to_string());
                            let _ = writeln!(file, "{}", json_line);
                        }
                        results.push(error_entry);
                        continue;
                    }
                }
            }
        };

        if !verify_resp.status().is_success() {
            eprintln!(
                "Error: Failed to verify security level (status {})",
                verify_resp.status()
            );
            let error_entry = ResultEntry {
                test_type: test_type.clone(),
                security_level: security_level.clone(),
                classification_result: JailbreakAttemptResultClassification::Error,
                prompt_text: prompt.clone(),
                reason: None,
                full_response: format!("Failed to verify security level (status {})", verify_resp.status()),
                timestamp: Utc::now(),
            };
            results.push(error_entry);
            continue;
        }

        let config_json: serde_json::Value = match verify_resp.json().await {
            Ok(json) => json,
            Err(e) => {
                let error_entry = ResultEntry {
                    test_type: test_type.clone(),
                    security_level: security_level.clone(),
                    classification_result: JailbreakAttemptResultClassification::Error,
                    prompt_text: prompt.clone(),
                    reason: None,
                    full_response: format!("Config verification JSON parse failed: {}", e),
                    timestamp: Utc::now(),
                };
                {
                    let mut file = output_file.lock().await;
                    let json_line = serde_json::to_string(&error_entry)
                        .unwrap_or_else(|_| r#"{"error":"serialization_failed"}"#.to_string());
                    let _ = writeln!(file, "{}", json_line);
                }
                results.push(error_entry);
                continue;
            }
        };
        let current_level = config_json["current_level"].as_str().unwrap_or("unknown");
        if current_level != security_level {
            eprintln!(
                "Error: Security level verification failed - expected '{}', got '{}'",
                security_level, current_level
            );
            let error_entry = ResultEntry {
                test_type: test_type.clone(),
                security_level: security_level.clone(),
                classification_result: JailbreakAttemptResultClassification::Error,
                prompt_text: prompt.clone(),
                reason: None,
                full_response: format!(
                    "Security level verification failed - expected '{}', got '{}'",
                    security_level, current_level
                ),
                timestamp: Utc::now(),
            };
            results.push(error_entry);
            continue;
        }

        // Second: Prepare chat request payload
        let chat_payload = serde_json::json!({
            "message": prompt
        });

        // Send chat request to API
        println!("ðŸ“¡ POST /api/chat - prompt: \"{}\"", prompt);
        let mut chat_retries = 0;
        let chat_resp = loop {
            match client.post(format!("{}/api/chat", target_url)).json(&chat_payload).send().await {
                Ok(resp) => break resp,
                Err(e) => {
                    if chat_retries < api_max_retries {
                        chat_retries += 1;
                        continue;
                    } else {
                        let error_entry = ResultEntry {
                            test_type: test_type.clone(),
                            security_level: security_level.clone(),
                            classification_result: JailbreakAttemptResultClassification::Error,
                            prompt_text: prompt.clone(),
                            reason: None,
                            full_response: format!("Chat request send failed: {}", e),
                            timestamp: Utc::now(),
                        };
                        {
                            let mut file = output_file.lock().await;
                            let json_line = serde_json::to_string(&error_entry)
                                .unwrap_or_else(|_| r#"{"error":"serialization_failed"}"#.to_string());
                            let _ = writeln!(file, "{}", json_line);
                        }
                        results.push(error_entry);
                        continue;
                    }
                }
            }
        };

        if !chat_resp.status().is_success() {
            eprintln!("Error: Chat API request failed with status {}", chat_resp.status());
            let error_entry = ResultEntry {
                test_type: test_type.clone(),
                security_level: security_level.clone(),
                classification_result: JailbreakAttemptResultClassification::Error,
                prompt_text: prompt.clone(),
                reason: None,
                full_response: format!("Chat API request failed with status {}", chat_resp.status()),
                timestamp: Utc::now(),
            };
            results.push(error_entry);
            continue;
        }

        // Parse response
        let response_json: serde_json::Value = match chat_resp.json().await {
            Ok(json) => json,
            Err(e) => {
                let error_entry = ResultEntry {
                    test_type: test_type.clone(),
                    security_level: security_level.clone(),
                    classification_result: JailbreakAttemptResultClassification::Error,
                    prompt_text: prompt.clone(),
                    reason: None,
                    full_response: format!("Chat response JSON parse failed: {}", e),
                    timestamp: Utc::now(),
                };
                {
                    let mut file = output_file.lock().await;
                    let json_line = serde_json::to_string(&error_entry)
                        .unwrap_or_else(|_| r#"{"error":"serialization_failed"}"#.to_string());
                    let _ = writeln!(file, "{}", json_line);
                }
                results.push(error_entry);
                continue;
            }
        };
        let response_text = response_json["response"].as_str().unwrap_or("");

        // Check for vulnerability based on test type
        let full_response = response_text.to_string();

        println!("Classifying with openai");

        let (classification_result, reason) = match classify_with_openai(
            &openai_client,
            response_text,
            test_type.as_str(),
            &prompt,
            evaluation_model,
        )
        .await
        {
            Ok((result, reason)) => (result, reason),
            Err(e) => {
                eprintln!("Warning: Classification failed for prompt \"{}\": {}", prompt, e);
                (JailbreakAttemptResultClassification::Error, None)
            }
        };

        // Create result entry
        let result_entry = ResultEntry {
            test_type,
            security_level,
            classification_result,
            prompt_text: prompt,
            reason,
            full_response,
            timestamp: Utc::now(),
        };

        // Write result immediately to file
        let mut file = output_file.lock().await;
        let json_line = match serde_json::to_string(&result_entry) {
            Ok(line) => line,
            Err(e) => {
                eprintln!("Failed to serialize result entry: {}", e);
                r#"{"error":"serialization_failed"}"#.to_string()
            }
        };
        if let Err(e) = writeln!(file, "{}", json_line) {
            eprintln!("Failed to write result to file: {}", e);
        }

        results.push(result_entry);

        // Third: Reset session after each prompt
        println!("ðŸ“¡ POST /api/reset");
        let mut reset_retries = 0;
        let reset_resp = loop {
            match client.post(format!("{}/api/reset", target_url)).send().await {
                Ok(resp) => break resp,
                Err(e) => {
                    if reset_retries < api_max_retries {
                        reset_retries += 1;
                        continue;
                    } else {
                        return Err(Box::new(e));
                    }
                }
            }
        };

        if !reset_resp.status().is_success() {
            eprintln!("Warning: Failed to reset session (status {})", reset_resp.status());
        }
    }

    Ok(results)
}

pub async fn run_processing(
    filter_test_type: Option<String>,
    target_url: String,
    prompts_file: String,
    concurrency: usize,
    api_max_retries: usize,
    provider: String,
    evaluation_model: String,
) -> Result<(Vec<ResultEntry>, Duration), Box<dyn std::error::Error + Send + Sync>> {
    let start_time = Instant::now();

    if let Some(ref test_type) = filter_test_type {
        println!(
            "Pentesting V.H.A.C.K. API for '{}'-type vulnerabilities only",
            test_type
        );
    } else {
        println!("Pentesting V.H.A.C.K. API for multiple vulnerability types");
    }
    println!("=======================================================");

    // Create a client that can handle cookies
    let client = ReqwestClient::builder().cookie_store(true).build()?;

    // Initialize OpenAI client
    let (api_key, base_url) = match provider.as_str() {
        "openai" => {
            let key = env::var("OPENAI_API_KEY")
                .expect("OPENAI_API_KEY environment variable must be set for openai provider");
            (key, "https://api.openai.com/v1".to_string())
        }
        "openrouter" => {
            let key = env::var("OPENROUTER_API_KEY")
                .expect("OPENROUTER_API_KEY environment variable must be set for openrouter provider");
            (key, "https://openrouter.ai/api/v1".to_string())
        }
        _ => unreachable!(),
    };
    let openai_client = Client::with_config(OpenAIConfig::new().with_api_key(api_key).with_api_base(base_url));

    // Open intermediate output file for shared access
    let temp_output_file = Arc::new(Mutex::new(
        OpenOptions::new().create(true).write(true).truncate(true).open("results.temp.jsonl")?,
    ));

    // Read prompts from prompts file
    let mut rdr = csv::ReaderBuilder::new().has_headers(true).from_path(&prompts_file)?;

    let mut all_prompts = Vec::new();
    for result in rdr.records() {
        let record = result?;
        let test_type = record[0].to_string();
        let security_level = record[1].to_string();
        let prompt = record[2].to_string();
        all_prompts.push((test_type, security_level, prompt));
    }

    // Split prompts into chunks for concurrency
    let chunk_size = (all_prompts.len() + concurrency - 1) / concurrency;
    let chunks: Vec<Vec<_>> = all_prompts.chunks(chunk_size).map(|c| c.to_vec()).collect();

    // Process chunks in parallel
    let mut tasks = Vec::new();
    for chunk in chunks {
        let client_clone = client.clone();
        let openai_client_clone = openai_client.clone();
        let filter_clone = filter_test_type.clone();
        let target_clone = target_url.clone();
        let output_clone = Arc::clone(&temp_output_file);
        let evaluation_model_clone = evaluation_model.clone();
        let task = spawn(async move {
            process_prompts(
                &client_clone,
                &openai_client_clone,
                chunk,
                &filter_clone,
                &target_clone,
                output_clone,
                api_max_retries,
                &evaluation_model_clone,
            )
            .await
        });
        tasks.push(task);
    }

    // Wait for all tasks to complete
    let results_futures = join_all(tasks).await;
    let mut all_results = Vec::new();
    for res in results_futures {
        match res {
            Ok(Ok(mut r)) => all_results.append(&mut r),
            Ok(Err(e)) => return Err(e),
            Err(e) => return Err(Box::new(e)),
        }
    }

    let elapsed = start_time.elapsed();

    Ok((all_results, elapsed))
}
