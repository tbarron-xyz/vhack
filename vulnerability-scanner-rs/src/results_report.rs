use chrono::{DateTime, Utc};
use std::io::{BufRead, Write};
use std::time::Duration;

use crate::result_classification::JailbreakAttemptResultClassification;

#[derive(serde::Serialize, serde::Deserialize)]
pub struct ResultEntry {
    pub test_type: String,
    pub security_level: String,
    pub classification_result: JailbreakAttemptResultClassification,
    pub prompt_text: String,
    pub reason: Option<String>,
    pub full_response: String,
    pub timestamp: DateTime<Utc>,
}

pub fn read_results_from_file(output_file: &str) -> Result<Vec<ResultEntry>, Box<dyn std::error::Error + Send + Sync>> {
    let mut results = Vec::new();
    if let Ok(file) = std::fs::File::open(output_file) {
        let reader = std::io::BufReader::new(file);
        for line in reader.lines() {
            let line = line?;
            let result: ResultEntry = serde_json::from_str(&line)?;
            results.push(result);
        }
    }
    Ok(results)
}

pub fn generate_summary_report(
    results: &[ResultEntry],
    filter_test_type: Option<&String>,
    elapsed: Duration,
    all_args: &[String],
    output_file: &str,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    let mut worked_count = 0;
    let mut didntwork_count = 0;
    let mut error_count = 0;
    let mut worked_examples: Vec<(String, String, Option<String>)> = Vec::new();
    let mut test_type_stats: std::collections::HashMap<&str, (i32, i32, i32)> = std::collections::HashMap::new();

    for result in results {
        match result.classification_result {
            JailbreakAttemptResultClassification::Worked => {
                worked_count += 1;
                worked_examples.push((
                    result.prompt_text.clone(),
                    result.security_level.clone(),
                    result.reason.clone(),
                ));
            }
            JailbreakAttemptResultClassification::DidntWork => {
                didntwork_count += 1;
            }
            JailbreakAttemptResultClassification::Error => {
                error_count += 1;
            }
        }

        // Use test_type from result for statistics
        let test_type = &result.test_type;
        let entry = test_type_stats.entry(test_type.as_str()).or_insert((0, 0, 0));
        match result.classification_result {
            JailbreakAttemptResultClassification::Worked => entry.0 += 1,
            JailbreakAttemptResultClassification::DidntWork => entry.1 += 1,
            JailbreakAttemptResultClassification::Error => entry.2 += 1,
        }
    }

    let mut summary = String::new();
    summary.push_str("# V.H.A.C.K. Jailbreak Report Summary\n\n");
    summary.push_str("This report summarizes the results of testing prompts from `prompts.csv` against the V.H.A.C.K. API for jailbreak success.\n\n");

    summary.push_str("## Statistics\n\n");
    summary.push_str(&format!("- **Total Prompts Tested:** {}\n", results.len()));
    summary.push_str(&format!(
        "- **Worked Prompts:** {} ({:.1}%)\n",
        worked_count,
        if results.len() > 0 {
            (worked_count as f64 / results.len() as f64) * 100.0
        } else {
            0.0
        }
    ));
    summary.push_str(&format!(
        "- **DidntWork Prompts:** {} ({:.1}%)\n",
        didntwork_count,
        if results.len() > 0 {
            (didntwork_count as f64 / results.len() as f64) * 100.0
        } else {
            0.0
        }
    ));
    summary.push_str(&format!(
        "- **Error Prompts:** {} ({:.1}%)\n\n",
        error_count,
        if results.len() > 0 {
            (error_count as f64 / results.len() as f64) * 100.0
        } else {
            0.0
        }
    ));

    if !worked_examples.is_empty() {
        summary.push_str("## Successful Jailbreaks\n\n");
        summary.push_str("These prompts successfully jailbroke the API:\n\n");
        for (prompt, security_level, reason) in worked_examples {
            summary.push_str(&format!("- **Prompt:** \"{}\"\n", prompt));
            summary.push_str(&format!("  - **Security Level:** {}\n", security_level));
            if let Some(r) = reason {
                summary.push_str(&format!("  - **Reason:** {}\n", r));
            }
            summary.push_str("\n");
        }
    }

    summary.push_str("## Details\n\n");
    summary.push_str("- Prompts were tested with security levels as specified in prompts.csv (medium or high)\n");
    summary.push_str("- Each prompt was tested in a fresh session\n");
    if filter_test_type.is_some() {
        summary.push_str(&format!(
            "- Filtered to test type: '{}'\n",
            filter_test_type.as_ref().unwrap()
        ));
    }
    summary.push_str("- Full results are available in `results.jsonl`\n");
    summary.push_str(&format!("- Total time elapsed: {:.2} seconds\n", elapsed.as_secs_f64()));
    summary.push_str(&format!("- Command line args: {}\n", all_args.join(" ")));
    summary.push_str("- Test completed at: ");
    summary.push_str(&Utc::now().to_rfc3339());

    // Add test type breakdown
    summary.push_str("\n\n## Test Types Breakdown\n\n");
    for (test_type, counts) in test_type_stats {
        let (worked, didntwork, error) = counts;
        let total = worked + didntwork + error;
        if total > 0 {
            summary.push_str(&format!("### {}\n", test_type));
            summary.push_str(&format!(
                "- **Worked:** {} ({:.1}%)\n",
                worked,
                (worked as f64 / total as f64) * 100.0
            ));
            summary.push_str(&format!(
                "- **DidntWork:** {} ({:.1}%)\n",
                didntwork,
                (didntwork as f64 / total as f64) * 100.0
            ));
            summary.push_str(&format!(
                "- **Error:** {} ({:.1}%)\n\n",
                error,
                (error as f64 / total as f64) * 100.0
            ));
        }
    }

    let mut file = std::fs::File::create("summary.md")?;
    file.write_all(summary.as_bytes())?;

    // Write summary.csv
    let csv_content = format!(
        "elapsed_seconds,total_prompts_tested,prompts_worked\n{},{},{}\n",
        elapsed.as_secs_f64(),
        results.len(),
        worked_count
    );
    let mut csv_file = std::fs::File::create("summary.csv")?;
    csv_file.write_all(csv_content.as_bytes())?;

    // Write the complete results to the output file
    let mut final_file = std::fs::File::create(output_file)?;
    for result in results {
        let json_line = serde_json::to_string(result)?;
        writeln!(final_file, "{}", json_line)?;
    }

    println!("\nðŸ“Š Reports generated:");
    println!("   - results.temp.jsonl (intermediate JSONL written during processing)");
    println!("   - {} (complete JSONL from results vector)", output_file);
    println!("   - summary.md (Markdown summary report)");

    Ok(())
}
