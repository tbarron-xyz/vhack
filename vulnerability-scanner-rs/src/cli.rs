use clap::Parser;

#[derive(Parser, Debug)]
#[command(name = "vulnerability-scanner-rs", about = "Vulnerability scanner using OpenAI API")]
pub struct CliArgs {
    #[arg(short = 't', long, help = "Filter prompts by test type")]
    pub filter_test_type: Option<String>,

    #[arg(long, default_value = "http://localhost:8000", help = "API target URL")]
    pub target_url: String,

    #[arg(long, default_value = "./prompts.csv", help = "Prompts CSV file")]
    pub prompts_file: String,

    #[arg(long, help = "Overall timeout in milliseconds")]
    pub timeout_ms: Option<u64>,

    #[arg(long, default_value = "results.jsonl", help = "Output JSONL file")]
    pub output_file: String,

    #[arg(long, default_value = "1", help = "Number of concurrent threads")]
    pub concurrency: usize,

    #[arg(long, default_value = "1", help = "Maximum API call retries on failure")]
    pub api_max_retries: usize,

    #[arg(long, help = "Generate prompts.csv using API based on vulnerability docs")]
    pub generate_prompts: bool,

    #[arg(long, help = "Analyze tools file for security vulnerabilities using API")]
    pub analyze_tools: bool,

    #[arg(long, default_value = "./tools.md", help = "Tools file to analyze")]
    pub tools_file: String,

    #[arg(long, help = "Analyze repository structure for security vulnerabilities using API")]
    pub analyze_repo: bool,

    #[arg(long, default_value = ".", help = "Repository path to analyze")]
    pub repo_path: String,

    #[arg(long = "exclude-path", help = "Path to exclude from analysis (can be used multiple times)")]
    pub exclude_paths: Vec<String>,

    #[arg(
        long,
        default_value = "openrouter",
        help = "API provider to use (openai or openrouter)"
    )]
    pub provider: String,

    #[arg(
        long,
        default_value = "openai/gpt-5-nano",
        help = "Model name to use for prompt generation"
    )]
    pub model: String,

    #[arg(
        long,
        default_value = "openai/gpt-5-nano",
        help = "Model name to use for prompt test success evaluation"
    )]
    pub evaluation_model: String,

    #[arg(
        long,
        default_value = "2000",
        help = "Maximum tokens for API calls when temperature=0"
    )]
    pub max_tokens: u32,
}

pub fn parse_args() -> CliArgs {
    let args = CliArgs::parse();
    // Validate provider
    if args.provider != "openai" && args.provider != "openrouter" {
        eprintln!("Error: --provider must be 'openai' or 'openrouter'");
        std::process::exit(1);
    }
    args
}

/// Get API credentials (key and base URL) for the specified provider
pub fn get_api_credentials(provider: &str) -> Result<(String, String), Box<dyn std::error::Error + Send + Sync>> {
    match provider {
        "openai" => {
            let key = std::env::var("OPENAI_API_KEY").map_err(|e| {
                Box::<dyn std::error::Error + Send + Sync>::from(format!(
                    "OPENAI_API_KEY environment variable must be set for openai provider: {}",
                    e
                ))
            })?;
            Ok((key, "https://api.openai.com/v1".to_string()))
        }
        "openrouter" => {
            let key = std::env::var("OPENROUTER_API_KEY").map_err(|e| {
                Box::<dyn std::error::Error + Send + Sync>::from(format!(
                    "OPENROUTER_API_KEY environment variable must be set for openrouter provider: {}",
                    e
                ))
            })?;
            Ok((key, "https://openrouter.ai/api/v1".to_string()))
        }
        _ => unreachable!(),
    }
}
