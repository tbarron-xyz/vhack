use std::env;

#[derive(Debug)]
pub struct CliArgs {
    pub filter_test_type: Option<String>,
    pub target_url: String,
    pub prompts_file: String,
    pub timeout_ms: Option<u64>,
    pub output_file: String,
    pub concurrency: usize,
    pub api_max_retries: usize,
    pub generate_prompts: bool,
    pub analyze_tools: bool,
    pub tools_file: String,
    pub provider: String,
    pub model: String,
    pub evaluation_model: String,
    pub max_tokens: u32,
}

pub fn parse_args() -> CliArgs {
    let args: Vec<String> = env::args().collect();
    let mut filter_test_type: Option<String> = None;
    let mut target_url = "http://localhost:8000".to_string();
    let mut prompts_file = "./prompts.csv".to_string();
    let mut timeout_ms: Option<u64> = None;
    let mut output_file = "results.jsonl".to_string();
    let mut concurrency: usize = 1;
    let mut api_max_retries: usize = 1;
    let mut generate_prompts: bool = false;
    let mut analyze_tools: bool = false;
    let mut tools_file = "./tools.md".to_string();
    let mut provider = "openrouter".to_string();
    let mut model = "openai/gpt-5-nano".to_string();
    let mut evaluation_model = "openai/gpt-5-nano".to_string();
    let mut max_tokens: u32 = 2000;

    // Basic argument parsing
    let mut i = 1;
    while i < args.len() {
        match args[i].as_str() {
            "--test-type" | "-t" => {
                if i + 1 < args.len() {
                    filter_test_type = Some(args[i + 1].clone());
                    i += 2;
                } else {
                    eprintln!("Error: --test-type requires a value");
                    print_usage_and_exit();
                }
            }
            "--target" => {
                if i + 1 < args.len() {
                    target_url = args[i + 1].clone();
                    i += 2;
                } else {
                    eprintln!("Error: --target requires a value");
                    print_usage_and_exit();
                }
            }
            "--prompts" => {
                if i + 1 < args.len() {
                    prompts_file = args[i + 1].clone();
                    i += 2;
                } else {
                    eprintln!("Error: --prompts requires a value");
                    print_usage_and_exit();
                }
            }
            "--timeout-ms" => {
                if i + 1 < args.len() {
                    match args[i + 1].parse::<u64>() {
                        Ok(ms) => {
                            timeout_ms = Some(ms);
                            i += 2;
                        }
                        Err(_) => {
                            eprintln!("Error: --timeout-ms requires a valid number");
                            print_usage_and_exit();
                        }
                    }
                } else {
                    eprintln!("Error: --timeout-ms requires a value");
                    print_usage_and_exit();
                }
            }
            "--out" => {
                if i + 1 < args.len() {
                    output_file = args[i + 1].clone();
                    i += 2;
                } else {
                    eprintln!("Error: --out requires a value");
                    print_usage_and_exit();
                }
            }
            "--concurrency" => {
                if i + 1 < args.len() {
                    match args[i + 1].parse::<usize>() {
                        Ok(c) => {
                            concurrency = c;
                            i += 2;
                        }
                        Err(_) => {
                            eprintln!("Error: --concurrency requires a valid number");
                            print_usage_and_exit();
                        }
                    }
                } else {
                    eprintln!("Error: --concurrency requires a value");
                    print_usage_and_exit();
                }
            }
            "--api-max-retries" => {
                if i + 1 < args.len() {
                    match args[i + 1].parse::<usize>() {
                        Ok(r) => {
                            api_max_retries = r;
                            i += 2;
                        }
                        Err(_) => {
                            eprintln!("Error: --api-max-retries requires a valid number");
                            print_usage_and_exit();
                        }
                    }
                } else {
                    eprintln!("Error: --api-max-retries requires a value");
                    print_usage_and_exit();
                }
            }
            "--generate-prompts" => {
                generate_prompts = true;
                i += 1;
            }
            "--analyze-tools" => {
                analyze_tools = true;
                i += 1;
            }
            "--tools-file" => {
                if i + 1 < args.len() {
                    tools_file = args[i + 1].clone();
                    i += 2;
                } else {
                    eprintln!("Error: --tools-file requires a value");
                    print_usage_and_exit();
                }
            }
            "--provider" => {
                if i + 1 < args.len() {
                    let prov = args[i + 1].clone();
                    if prov == "openai" || prov == "openrouter" {
                        provider = prov;
                        i += 2;
                    } else {
                        eprintln!("Error: --provider must be 'openai' or 'openrouter'");
                        print_usage_and_exit();
                    }
                } else {
                    eprintln!("Error: --provider requires a value");
                    print_usage_and_exit();
                }
            }
            "--model" => {
                if i + 1 < args.len() {
                    model = args[i + 1].clone();
                    i += 2;
                } else {
                    eprintln!("Error: --model requires a value");
                    print_usage_and_exit();
                }
            }
            "--evaluation-model" => {
                if i + 1 < args.len() {
                    evaluation_model = args[i + 1].clone();
                    i += 2;
                } else {
                    eprintln!("Error: --evaluation-model requires a value");
                    print_usage_and_exit();
                }
            }
            "--max-tokens" => {
                if i + 1 < args.len() {
                    match args[i + 1].parse::<u32>() {
                        Ok(mt) => {
                            max_tokens = mt;
                            i += 2;
                        }
                        Err(_) => {
                            eprintln!("Error: --max-tokens requires a valid number");
                            print_usage_and_exit();
                        }
                    }
                } else {
                    eprintln!("Error: --max-tokens requires a value");
                    print_usage_and_exit();
                }
            }
            "--help" | "-h" => {
                print_usage_and_exit();
            }
            _ => {
                eprintln!("Unknown argument: {}", args[i]);
                print_usage_and_exit();
            }
        }
    }

    CliArgs {
        filter_test_type,
        target_url,
        prompts_file,
        timeout_ms,
        output_file,
        concurrency,
        api_max_retries,
        generate_prompts,
        analyze_tools,
        tools_file,
        provider,
        model,
        evaluation_model,
        max_tokens,
    }
}

/// Get API credentials (key and base URL) for the specified provider
pub fn get_api_credentials(provider: &str) -> Result<(String, String), Box<dyn std::error::Error + Send + Sync>> {
    match provider {
        "openai" => {
            let key = std::env::var("OPENAI_API_KEY").map_err(|e| {
                Box::<dyn std::error::Error + Send + Sync>::from(format!(
                    "OPENAI_API_KEY environment variable must be set for openai provider: {}",
                    e
                ))
            })?;
            Ok((key, "https://api.openai.com/v1".to_string()))
        }
        "openrouter" => {
            let key = std::env::var("OPENROUTER_API_KEY").map_err(|e| {
                Box::<dyn std::error::Error + Send + Sync>::from(format!(
                    "OPENROUTER_API_KEY environment variable must be set for openrouter provider: {}",
                    e
                ))
            })?;
            Ok((key, "https://openrouter.ai/api/v1".to_string()))
        }
        _ => unreachable!(),
    }
}

fn print_usage_and_exit() -> ! {
    eprintln!(
        "Usage: {} [OPTIONS]",
        env::args().next().unwrap_or("vulnerability-scanner-rs".into())
    );
    eprintln!();
    eprintln!("Options:");
    eprintln!("  --target <URL>                     API target URL (default: http://localhost:8000)");
    eprintln!("  --prompts <FILE>                   Prompts CSV file (default: ./prompts.csv)");
    eprintln!("  --timeout-ms <MS>                  Overall timeout in milliseconds (default: no timeout)");
    eprintln!("  --out <FILE>                       Output JSONL file (default: results.jsonl)");
    eprintln!("  --concurrency <N>                  Number of concurrent threads (default: 1)");
    eprintln!("  --api-max-retries <N>              Maximum API call retries on failure (default: 1)");
    eprintln!("  --generate-prompts                 Generate prompts.csv using API based on vulnerability docs");
    eprintln!("  --analyze-tools                    Analyze tools file for security vulnerabilities using API");
    eprintln!("  --tools-file <FILE>                Tools file to analyze (default: ./tools.md)");
    eprintln!("  --provider <openai|openrouter>     API provider to use (default: openrouter)");
    eprintln!(
        "  --model <MODEL>                    Model name to use for prompt generation (default: openai/gpt-5-nano)"
    );
    eprintln!("  --evaluation-model <MODEL>         Model name to use for prompt test success evaluation (default: openai/gpt-5-nano)");
    eprintln!("  --max-tokens <N>                   Maximum tokens for API calls when temperature=0 (default: 2000)");
    eprintln!("  --test-type <TYPE>, -t <TYPE>      Filter prompts by test type (passwd, user_credential_extraction, financial_pii_exposure, ssn_last4_exposure, system_prompt_bypass, command_injection_process_enumeration, command_injection_file_manipulation, network_active_connections, system_user_enumeration)");
    eprintln!("  --help, -h                         Show this help message");
    eprintln!();
    eprintln!("Examples:");
    eprintln!(
        "  {}                                    Run all prompts",
        env::args().next().unwrap_or("vulnerability-scanner-rs".into())
    );
    eprintln!(
        "  {} --test-type passwd                Run only passwd prompts",
        env::args().next().unwrap_or("vulnerability-scanner-rs".into())
    );
    eprintln!(
        "  {} --target http://example.com:8000 --concurrency 4  Run with custom target and 4 threads",
        env::args().next().unwrap_or("vulnerability-scanner-rs".into())
    );
    std::process::exit(1);
}
