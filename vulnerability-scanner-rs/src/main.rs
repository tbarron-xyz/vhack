use std::env;
use std::time::{Duration, Instant};
use tokio::time::timeout;

mod cli;
mod prompt_generator;
mod prompt_processing;
mod result_classification;
mod results_report;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    let cli_args = cli::parse_args();

    // Handle prompt generation mode
    if cli_args.generate_prompts {
        let (api_key, base_url) = match cli_args.provider.as_str() {
            "openai" => {
                let key = std::env::var("OPENAI_API_KEY").map_err(|e| {
                    Box::<dyn std::error::Error + Send + Sync>::from(format!(
                        "OPENAI_API_KEY environment variable must be set for openai provider: {}",
                        e
                    ))
                })?;
                (key, "https://api.openai.com/v1".to_string())
            }
            "openrouter" => {
                let key = std::env::var("OPENROUTER_API_KEY").map_err(|e| {
                    Box::<dyn std::error::Error + Send + Sync>::from(format!(
                        "OPENROUTER_API_KEY environment variable must be set for openrouter provider: {}",
                        e
                    ))
                })?;
                (key, "https://openrouter.ai/api/v1".to_string())
            }
            _ => unreachable!(),
        };

        let generator =
            prompt_generator::PromptGenerator::new(api_key, base_url, cli_args.model, cli_args.api_max_retries);
        return generator.generate_prompts(&cli_args.prompts_file, cli_args.concurrency).await;
    }

    let all_args: Vec<String> = env::args().collect();

    let start_time = Instant::now();

    if let Some(ms) = cli_args.timeout_ms {
        match timeout(
            Duration::from_millis(ms),
            prompt_processing::run_processing(
                cli_args.filter_test_type.clone(),
                cli_args.target_url,
                cli_args.prompts_file,
                cli_args.concurrency,
                cli_args.api_max_retries,
                cli_args.provider.clone(),
                cli_args.model.clone(),
            ),
        )
        .await
        {
            Ok(Ok((results, elapsed))) => {
                results_report::generate_summary_report(
                    &results,
                    cli_args.filter_test_type.as_ref(),
                    elapsed,
                    &all_args,
                    &cli_args.output_file,
                )?;
                Ok(())
            }
            Ok(Err(e)) => Err(e),
            Err(_) => {
                eprintln!("Overall timeout of {}ms reached", ms);
                let elapsed = start_time.elapsed();
                let results = results_report::read_results_from_file("results.temp.jsonl")?;
                results_report::generate_summary_report(
                    &results,
                    cli_args.filter_test_type.as_ref(),
                    elapsed,
                    &all_args,
                    &cli_args.output_file,
                )?;
                Ok(())
            }
        }
    } else {
        let (results, elapsed) = prompt_processing::run_processing(
            cli_args.filter_test_type.clone(),
            cli_args.target_url,
            cli_args.prompts_file,
            cli_args.concurrency,
            cli_args.api_max_retries,
            cli_args.provider.clone(),
            cli_args.model.clone(),
        )
        .await?;
        results_report::generate_summary_report(
            &results,
            cli_args.filter_test_type.as_ref(),
            elapsed,
            &all_args,
            &cli_args.output_file,
        )?;
        Ok(())
    }
}
