use std::env;
use std::time::{Duration, Instant};
use tokio::time::timeout;

mod cli;
mod prompt_generator;
mod prompt_processing;
mod result_classification;
mod results_report;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    let cli_args = cli::parse_args();

    // Handle prompt generation mode
    if cli_args.generate_prompts {
        let api_key =
            std::env::var("OPENAI_API_KEY").or_else(|_| std::env::var("OPENROUTER_API_KEY")).map_err(|e| {
                Box::<dyn std::error::Error + Send + Sync>::from(format!(
                    "OPENAI_API_KEY or OPENROUTER_API_KEY environment variable must be set: {}",
                    e
                ))
            })?;

        let generator = prompt_generator::PromptGenerator::new(api_key);
        return generator.generate_prompts(&cli_args.prompts_file, cli_args.concurrency).await;
    }

    let all_args: Vec<String> = env::args().collect();

    let start_time = Instant::now();

    if let Some(ms) = cli_args.timeout_ms {
        match timeout(
            Duration::from_millis(ms),
            prompt_processing::run_processing(
                cli_args.filter_test_type.clone(),
                cli_args.target_url,
                cli_args.prompts_file,
                cli_args.concurrency,
                cli_args.api_max_retries,
            ),
        )
        .await
        {
            Ok(Ok((results, elapsed))) => {
                results_report::generate_summary_report(
                    &results,
                    cli_args.filter_test_type.as_ref(),
                    elapsed,
                    &all_args,
                    &cli_args.output_file,
                )?;
                Ok(())
            }
            Ok(Err(e)) => Err(e),
            Err(_) => {
                eprintln!("Overall timeout of {}ms reached", ms);
                let elapsed = start_time.elapsed();
                let results = results_report::read_results_from_file("results.temp.jsonl")?;
                results_report::generate_summary_report(
                    &results,
                    cli_args.filter_test_type.as_ref(),
                    elapsed,
                    &all_args,
                    &cli_args.output_file,
                )?;
                Ok(())
            }
        }
    } else {
        let (results, elapsed) = prompt_processing::run_processing(
            cli_args.filter_test_type.clone(),
            cli_args.target_url,
            cli_args.prompts_file,
            cli_args.concurrency,
            cli_args.api_max_retries,
        )
        .await?;
        results_report::generate_summary_report(
            &results,
            cli_args.filter_test_type.as_ref(),
            elapsed,
            &all_args,
            &cli_args.output_file,
        )?;
        Ok(())
    }
}
